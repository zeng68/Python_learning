from abc import ABCMeta, abstractmethod


class Animal(metaclass=ABCMeta):
    @abstractmethod
    def make_sound(self):
        pass
"""抽象方法的定义通过@abstractmethod装饰器实现。它强制子类实现抽象方法，以满足抽象基类的接口约束。
当子类没有实现抽象方法时，会引发TypeError错误。抽象方法的具体实现应该在子类中完成，确保子类具备特定的行为和功能。
一个类继承自抽象基类但没有实现所有的抽象方法，那么它也会被认为是抽象类，不能被实例化
"""

class Dog(Animal):
    def make_sound(self):
        print("Woof!")


class Cat(Animal):
    def make_sound(self):
        print("Meow!")


# 无法实例化Animal类，因为它是一个抽象基类
# animal = Animal()

dog = Dog()
dog.make_sound()  # 输出: Woof!

cat = Cat()
cat.make_sound()  # 输出: Meow!

""""Animal是一个抽象基类，它定义了一个抽象方法make_sound。Dog和Cat是继承自Animal的具体子类，并实现了make_sound方法。
由于Animal是抽象基类，不能被实例化。只有具体子类Dog和Cat可以被实例化。子类必须实现父类中的抽象方法，否则会引发错误。
在这个例子中，抽象基类Animal提供了一个共享的接口make_sound，要求子类实现该方法以定义具体的动物叫声。子类Dog和Cat分别实现了make_sound方法，并定义了它们自己的叫声。

使用抽象基类（Abstract Base Class）时，有一些注意事项和优点：

注意事项：
1. 抽象基类不能被实例化，只能被用作其他类的基类。
2. 子类继承抽象基类时，必须实现抽象基类中定义的抽象方法，否则会引发错误。
3. 抽象基类可以定义非抽象方法和属性，子类可以直接继承和使用它们。

优点：
1. 规范接口：抽象基类定义了一组共享的接口，可以确保子类实现了这些接口。这有助于代码的规范性和一致性。
2. 提供约束：抽象基类可以约束子类必须实现的方法和属性，确保子类具有特定的行为和特征。
3. 促进多态性：通过继承抽象基类并实现其抽象方法，不同的子类可以表现出不同的行为，实现多态性的效果。
4. 便于扩展：当需要增加新的子类时，可以直接继承抽象基类并实现抽象方法，而无需修改现有代码。

总的来说，抽象基类提供了一种规范化接口和约束子类的方式，使得代码更易于维护、扩展和重用。它们可以提高代码的可读性、可靠性和灵活性，并促进面向对象编程中的多态性。在大型项目中，
抽象基类的使用可以更好地组织代码结构，减少重复代码，并降低代码的耦合度。

"""
